Since 1960s, software development has been evolving rapidly to address the increasing demands of complex software. The complexity of modern software brings about difficulties in developing and maintaining quality software. Software engineering as a discipline ensures that developers follow a systematic production of software, by applying best practices to maximize quality of deliverables and minimize time-to-market. Various methodologies exist through the efforts of active research by theorists and practitioners, but the core of software development process typically consists of the following six phases---requirements gathering, design, implementation, testing, deployment, and maintenance.

Conceptual models help illustrates complex systems with a simple framework by creating abstractions to alleviate the amount of complexity. Hence, the use of models is progressively recommended in representing a software system. This simplifies the process of design, maximizes compatibility between different platforms, and promotes communication among stakeholders. Model-Driven Engineering (MDE) technologies offer the means to represent domain-specific knowledge within models, allowing modelers to express domain concepts effectively \cite{schmidt2006model}. MDE advocates using the best modeling formalism that expresses relevant design intent declaratively at each level of abstraction. During development, we can use models to describe different aspects of the system vertically, in which the models are refined from higher to lower levels of abstraction through model transformation. At the lowest level, models use implementation technology concepts, and appropriate tools can be used to generate code from these platform-specific models \cite{sendall2003model}.

Modularity is key in designing computer programs that are extensible and easily maintainable, but concerns that are crosscutting and more scattered in the implementation are more likely to cause defects \cite{eaddy2008crosscutting}. This poses obstacles for MDE because modeling such crosscutting concerns in a modular way is difficult from an object-oriented standpoint. Furthermore, reusability is also a main factor in allowing developers to leverage reusable solutions such as libraries and frameworks provided for a given programming language, thereby improving the development speed without having to implement existing software components from first principles. Model reuse is still in its early stage, but modeling libraries are emerging as well \cite{france2012repository}.

Concern-Oriented Reuse (CORE) introduces a modeling technique that focuses on concerns as units of reuse \cite{alam2013concern}. CORE enables large-scale model reuse by utilizing the ideas of MDE, Separation of Concerns (SoC), and Software Product Lines (SPL). This is possible because CORE uses aspect-oriented modeling techniques to allow complex models to be built by incrementally composing smaller, simpler models. Current state of CORE supports models at the design phase \cite{kienzle2010aspect}, but models of other development phases can also be supported by integrating with the CORE metamodel to benefit from advanced modularization and reuse support.

This thesis focuses on models at the requirements phase, typically built earlier than design models, and the User Requirements Notation (URN) sets the standard as a visual notation for modeling and analyzing requirements \cite{amyot2002urn}. URN formalizes and integrates two complementary languages: (i) Goal-oriented Requirements Language (GRL) to describe non-functional requirements as intentional elements, and (ii) Use Case Map (UCM) to describe functional requirements as causal scenarios. GRL and UCM are used to capture goal and scenario models, respectively. Since CORE already supports the use of goal models to analyze the impact of choosing features \cite{alam2013concern}, we are interested in examining the possibility of having scenario models as part of the CORE toolkit. The goal of this thesis is to determine how UCMs can be integrated with the concepts of CORE. This leads to the question that begs to be investigated---whether actual MDE, i.e., software development with models at multiple levels of abstraction and model transformations that connect them, is compatible with CORE.

The remainder of this thesis is structured as follows. Chapter \ref{ch:2} offers background information on CORE and UCM. Chapter \ref{ch:3} presents the integration of CORE with UCM. Chapter \ref{ch:4} validates the resulting integration process. Finally, Chapter \ref{ch:5} concludes the thesis and discusses future work.
