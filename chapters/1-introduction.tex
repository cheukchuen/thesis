% !TEX root = ../thesis.tex

Since 1960s, software development has been evolving rapidly to address the increasing demands of complex software. The complexity of modern software brings about difficulties in developing and maintaining quality software. Software engineering as a discipline ensures that developers follow a systematic production of software, by applying best practices to maximize quality of deliverables and minimize time-to-market. Various methodologies exist through the efforts of active research by theorists and practitioners, but the core of software development process typically consists of the following six phases---requirements gathering, design, implementation, testing, deployment, and maintenance.

Conceptual models help illustrates complex systems with a simple framework by creating abstractions to alleviate the amount of complexity. Hence, the use of models is progressively recommended in representing a software system. This simplifies the process of design, maximizes compatibility between different platforms, and promotes communication among stakeholders. Model-Driven Engineering (MDE) technologies offer the means to represent domain-specific knowledge within models, allowing modelers to express domain concepts effectively~\cite{schmidt2006model}. MDE advocates using the best modeling formalism that expresses relevant design intent declaratively at each level of abstraction. During development, we can use models to describe different aspects of the system vertically, in which the models are refined from higher to lower levels of abstraction through model transformation. At the lowest level, models use implementation technology concepts, and appropriate tools can be used to generate code from these platform-specific models~\cite{sendall2003model}.

Modularity is key in designing computer programs that are extensible and easily maintainable, but concerns that are crosscutting and more scattered in the implementation are more likely to cause defects~\cite{eaddy2008crosscutting}. This poses obstacles for MDE because modeling such crosscutting concerns in a modular way is difficult from an object-oriented standpoint. Furthermore, reusability is also a main factor in allowing developers to leverage reusable solutions such as libraries and frameworks provided for a given programming language, thereby improving the development speed without having to implement existing software components from first principles. Model reuse is still in its early stage, but modeling libraries are emerging as well~\cite{france2012repository}.

\todo[inline]{Excellent intro up to here. I'd introduce CORE here more as a paradigm rather than a modeling technique. For example:}
\jkReplace{Concern-Oriented Reuse (CORE) introduces a modeling technique that focuses on concerns as units of reuse~\cite{alam2013concern}. CORE enables large-scale model reuse by utilizing the ideas of MDE, Separation of Concerns (SoC), and Software Product Lines (SPL). This is possible because CORE uses aspect-oriented modeling techniques to enable developers to build complex models by incrementally composing smaller, simpler models.}
{Concern-Oriented Reuse (CORE) is a new software development paradigm or approach that puts reuse at the forefront of software development~\cite{alam2013concern}. In CORE, software development is structured around modules called \emph{concerns} that provide a variety of reusable solutions for recurring software development issues. Techniques from Model-Driven Engineering (MDE), SPL engineering, and software composition (in particular feature-orientation and aspect-orientation) allow concerns to form modular units of reuse that encapsulate a set of software development artifacts, i.e., models and code, during software development in a versatile, generic way.\\
The main premise of CORE is that recurring development concerns are made available in a concern library, which eventually should cover most recurring software development needs. Similar to class libraries in modern programming languages, this library should grow as new development concerns emerge, and existing concerns should continuously evolve as alternative architectural, algorithmic, and technological solutions become available. Applications are built by reusing existing concerns from the library whenever possible, following a well-defined reuse process supported by clear interfaces. To generate an executable in which concerns exhibit intricate crosscutting structure and behaviour, CORE relies on additive software composition techniques, feature-oriented technology and aspect-oriented technology.}

Currently, CORE supports models at the design phase~\cite{kienzle2010aspect} only, but \jkReplace{}{in order to fully integrate CORE with MDE,} models \jkReplace{of}{typically used in} other development phases \jkReplace{can}{should} also be supported \jkReplace{by integrating with the CORE metamodel}{to allow them also}  to benefit from advanced modularization and reuse support.

This thesis focuses on \jkReplace{}{adding support for CORE to} models at the requirements phase, i.e., models that are typically built earlier than design models. \jkReplace{, and}{We chose to concentrate on} the User Requirements Notation (URN), which sets the standard as a visual notation for modeling and analyzing requirements~\cite{amyot2002urn}. URN formalizes and integrates two complementary languages: (i) Goal-oriented Requirements Language (GRL) to describe non-functional requirements as intentional elements, and (ii) Use Case Map (UCM) to describe functional requirements as causal scenarios. GRL and UCM are used to capture goal and scenario models, respectively. Since CORE already supports the use of goal models to analyze the impact of choosing features~\cite{alam2013concern}, we \jkReplace{are interested in examining the possibility of having}{concentrated in this thesis on integrating} scenario models \jkReplace{as part of the CORE toolkit. The goal of this thesis is to determine how UCMs can be integrated }{} with the concepts of CORE.

\todo[inline]{This last sentence I would move to future work at the end of the conclusion chapter} \jkReplace{This leads to the question that begs to be investigated---whether actual MDE, i.e., software development with models at multiple levels of abstraction and model transformations that connect them, is compatible with CORE.}{}

\section{Contributions}

This thesis advances the state-of-the-art in modelling by proposing a complete solution for augmenting the use case maps modelling notation with concern-oriented reuse capabilities. Specifically, the thesis makes the following contributions:

\todo[inline]{I just filled in some items, but there might be more, and each of them needs a little bit more explanation about what the contribution is and why it is important}

\begin{itemize}

\item UCM metamodel integration with CORE

\item Definition of UCM weaving algorithm compatible with CORE extension and reuse composition

\item Validation of feasibility of proposed solution by implementing metamodel and algorithm in TouchCORE

\item Validation of expressiveness of corified UCMs and demonstration of reuse potential by modelling the  xxx. case studies

\end{itemize}

\section{Thesis Outline}

The remainder of this thesis is structured as follows. Chapter~\ref{ch:2} offers background information on CORE and UCM. Chapter~\ref{ch:3} presents the integration of CORE with UCM. Chapter~\ref{ch:4} validates the resulting integration process. Finally, Chapter~\ref{ch:5} concludes the thesis and discusses future work.
\todo[inline]{Where are you talking about related work? It must be mentioned in the outline as well.}

