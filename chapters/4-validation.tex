The definition of UCM metamodel and the specification of weaving algorithm described in the previous chapter provide the foundation for the implementation of UCM in TouchCORE, a multitouch-enabled concern-oriented software design modeling tool. In this chapter, we illustrate the realization of scenario models in TouchCORE through the use of UCM notation in section~\ref{sec:4.1}. Then we attempt to validate our proposed approach of CoUCMs by means of case studies in section~\ref{sec:4.2}. Finally, we demonstrate that CoUCMs are able to cover the workflow patterns in section~\ref{sec:4.3}.

\section{UCM Implementation in TouchCORE} \label{sec:4.1}

TouchCORE is under active development within the Software Engineering Lab at McGill University \cite{sel2018touchcore}. The previous project, TouchRAM, successfully implemented the aspect-oriented software design paradigm, but support is limited to models expressed using the RAM modelling notation, which integrates class, sequence, and state diagrams in one language \cite{al2012touchram, schottle2014touchram}. TouchCORE extends TouchRAM with numerous enhancements, most notably the support for feature and goal modelling. While CORE also, in theory, supports multiple modelling languages, TouchCORE only supported design modeling using RAM. Since we have a well-defined corified UCM metamodel, we attempt to add support for CoUCM in TouchCORE as proof of concept, enabling TouchCORE to build scalable and reusable scenario models.

The project uses Java SE Development Kit 8 as the implementation language and Eclipse Modeling Framework (EMF)~\cite{steinberg2008emf} as the modeling facility for developing TouchCORE. To support a new language, we need to define its metamodel based on Ecore. TouchCORE already has a complete CORE metamodel defined with an Ecore model (see Figure~\ref{fig:a.1}). With RAM as a reference model, we constructed an Ecore model that expresses our complete UCM metamodel, subclassing the appropriate CORE metaclasses, through the use of EMF tooling (see Figure~\ref{fig:a.2} in Appendix~\ref{ch:A} for complete UCM metamodel). EMF is capable of generating structured Java code from valid Ecore models, allowing us to rapidly program the logic for UCM integration.

\begin{figure}
	\centering
	\includegraphics[scale=0.5]{fig_4_1.png}
	\caption[TouchCORE architecture]{TouchCORE architecture. Image courtesy of Software Engineering Lab, McGill University}
	\label{fig:4.1}
\end{figure}

The software architecture of TouchCORE follows the model–view–controller (MVC) design pattern to separate the program into three main logical components. Figure~\ref{fig:4.1} shows the three interconnected parts for the TouchCORE application: (i) the model layer for managing data, e.g., instances of RAM and UCM models; (ii) the TouchCORE graphical user interface (GUI) that constitutes the view layer for visualizing and manipulating models; and (iii) the controller layer for handling user interactions and act on the data model objects. The GUI for TouchCORE is built on top of MT4j for its multitouch capability \cite{laufs2010mt4j}. Additional components include weaver, code generator, model validator, and classloader. The integration of UCM in TouchCORE involves modifying its core components with varying degrees, but the program is structured in such a way that we can add subcomponents when implementing a new modeling language, adhering to the open/closed principle.

\subsection{Supported Concrete Syntax}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.3]{fig_4_2.png}
	\caption{UCM notation in TouchCORE}
	\label{fig:4.2}
\end{figure}

The basic elements of the UCM notation that we implemented in TouchCORE are shown in Figure~\ref{fig:4.2}. Most of these elements are defined by the standards~\cite{itu2012151}, with the exception of {\cls Anything} that is taken from the extended AoUCM metamodel~\cite{mussbacher2011aspect}. Users can create path nodes by tap-and-hold on the canvas of TouchCORE during runtime and a list of path nodes will be displayed for selection. To create a node connection between two path nodes, simply drag from the area adjacent of one element to the other element.

There are several anomalies with regards to the graphical representation of UCM symbols displayed in TouchCORE as compared with the standards (compare Figure~\ref{fig:4.2} with Figure~\ref{fig:2.7}). For example, the symbol for OR-fork and OR-join is shown as a circle instead of no symbol (just direct branching and merging from the paths); anything is represented as a square with the label \ldots\ instead of just \ldots; and node connection is a straight line path instead of spline. These are some of the limitations that we faced at the moment when implementing the GUI. Our current method of creating nodes is to first create them on the canvas, then build the connections later. OR-fork and OR-join need a space to receive events from the user, thus a circle serves as the area of interactivity as well as a statement of presence that an OR-fork or OR-join has been created. The idea of displaying the \ldots symbol of an anything node is that it should be part of the node connection and move along seamlessly with correct orientation whenever the predecessor or successor node of anything is moved, but since anything is considered a path node, we decided for now to just use a square with the label \ldots\ to represent the anything node. Lastly, spline drawing is not yet available in TouchCORE so we use straight lines for the time being.

\begin{figure}
	\centering
	\includegraphics[scale=0.3]{fig_4_3.png}
	\caption{Visibility and partiality}
	\label{fig:4.3}
\end{figure}

Elements with extra features can be accessed by tap-and-hold an element (Figure~\ref{fig:4.3}). We allow both start and end points to set their visibility. By default, all path nodes are \emph{concern visible}, but start and end points can switch to \emph{public visible} (see Section~\ref{sec:3.2.1.1} for visibility discussion). Likewise, we allow responsibilities to set their partiality. By default, all path nodes are not partial, meaning they are well-defined and require no further action. Since we have customization mappings for responsibility, we can specify whether a responsibility is partially defined, i.e., requires a composition to be semantically complete. A responsibility that is \emph{concern partial} should be completed through model extension, whereas a responsibility that is \emph{public partial} should be completed through model reuse.

\subsection{Scenario Model Composition}

\subsubsection{Model Extension}

\begin{figure}[h]
	\centering
	\subfloat[Model A - parent UCM]{\label{fig:4.4a}\includegraphics[clip,width=0.7\columnwidth]{fig_4_4a.png}} \\
	\subfloat[Model B - child UCM]{\label{fig:4.4b}\includegraphics[clip,width=0.7\columnwidth]{fig_4_4b.png}} \\
	\subfloat[Woven Model B\_A]{\label{fig:4.4c}\includegraphics[clip,width=0.7\columnwidth]{fig_4_4c.png}}
	\caption{Schematic representation of model extension}
	\label{fig:4.4}
\end{figure}

Figure~\ref{fig:4.4} illustrates the usage of UCM model extension within a concern. Given a concern with two features in a hierarchy, the model of a child feature (Model B) extends the model of a parent feature (Model A). Composition specifications are specified in Model B, where an element of Model A is mapped to an element of Model B. Multiple mappings can be set per extension as needed and the available types of mapping are defined in the metamodel. The result of weaving Model B to Model A is depicted in Figure~\ref{fig:4.4c}. Based on the mappings set in Model B, the predecessors and successors of the mapped responsibility from Model B are introduced as adjoined path nodes of the mapped responsibility from Model A, and the mapped responsibility from Model A is being replaced with the mapped responsibility from Model B.

\subsubsection{Model Reuse}

\begin{figure}
	\centering
	\subfloat[Model C - reuse Concern A with selected features <A,B>]{\label{fig:4.5a}\includegraphics[clip,width=0.7\columnwidth]{fig_4_5a.png}} \\
	\subfloat[Model C - establish connecting point mapping through node connection]{\label{fig:4.5b}\includegraphics[clip,width=0.7\columnwidth]{fig_4_5b.png}} \\
	\subfloat[Woven Model C\_A<A,B>]{\label{fig:4.5c}\includegraphics[clip,width=0.7\columnwidth]{fig_4_5c.png}}
	\caption{Schematic representation of model reuse}
	\label{fig:4.5}
\end{figure}

Figure~\ref{fig:4.5} illustrates the usage of UCM model reuse across concerns. Given that Model C of a concern reuses Concern A, the configuration for the set of features of Concern A will be displayed. Here, we chose to use features A and B, thus woven Model B\_A (see Figure~\ref{fig:4.4c}) is generated and represented as a static Stub A (appears automatically in canvas after successful reuse). Mappings for connecting points of Stub A can be established by linking a path node to/from Stub A. As shown in Figures~\ref{fig:4.5a} and~\ref{fig:4.5b}, a node connection was created from Stub A to an end point, and a list of end points from woven Model B\_A will be displayed for the user to set which end point of Model B\_A corresponds to which outgoing connection of Stub A in Model C. We label the incoming connection of a stub as \verb|<Model_2>.Stub[<Model_1>].In[<Predecessor>]|, and the outgoing connection as \verb|<Model_2>.Stub[<Model_1>].Out[<Successor>]|. The result of weaving Model B\_A into Model C is depicted in Figure~\ref{fig:4.5c}.

\section{Case Studies} \label{sec:4.2}

In this section, we attempt to validate our proposed technique for CoUCMs with two case studies: Authentication and Online Payment. We chose these two examples as our case studies because they provide different yet appropriate level of complexity to the problem that we are studying, exemplify model extension within the Online Payment concern, as well as showcase the reuse of the Authentication concern within the Online Payment concern.

\subsection{Authentication}

\begin{figure}[h]
	\centering
	\includegraphics[scale=0.5]{fig_4_6.png}
	\caption[Feature model for Authentication (jUCMNav)]{Feature model for Authentication (jUCMNav). Image courtesy of Nishanth Thimmegowda et al.~\cite{thimmegowda2014concern}}
	\label{fig:4.6}
\end{figure}

We design the Authentication concern based on a reference model that we have previously described in jUCMNav format~\cite{thimmegowda2014concern}. Figure~\ref{fig:4.6} shows all the available features that are supported for the concern. \emph{Authentication} has a mandatory \emph{Authentication Means} feature that may either be \emph{Password} that can be extended with the optional \emph{Password Expiry} feature, or \emph{Biometrics} that requires at least \emph{Retinal Scan} or \emph{Voice Recognition}. If necessary, consecutive unsuccessful authentication attempts may result in \emph{Access Blocking} and long idle period may lead to \emph{Auto Logoff}.

\begin{figure}
	\centering
	\includegraphics[scale=2]{fig_4_7.png}
	\caption[Scenario models for Authentication (jUCMNav)]{Scenario models for Authentication (jUCMNav). Image courtesy of Nishanth Thimmegowda et al.~\cite{thimmegowda2014concern}}
	\label{fig:4.7}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[scale=1.2]{fig_4_8.png}
	\caption{Scenario models for Authentication (TouchCORE)}
	\label{fig:4.8}
\end{figure}

Scenario models can be (optionally) realized for the features to describe how the user would interact with the Authentication concern. Figure~\ref{fig:4.7} illustrates the UCM diagrams and plug-ins that are realized for most of the features. Then, with slight modifications to the UCMs specified in jUCMNav, we developed our version of the UCMs using TouchCORE as depicted in Figure~\ref{fig:4.8}. (Feature model remains unchanged and TouchCORE version of the feature model is omitted.)

Notice that in the root map of Figure~\ref{fig:4.7}, each feature is represented as a static stub and is bound to a plug-in for the feature. In the root map developed using TouchCORE (see Figure~\ref{fig:4.8}), we minimize the usage of stubs and instead utilize model extensions, successfully isolating the aspects that crosscut the main concern. Since \emph{Authentication Means} is a mandatory feature, we introduce a responsibility placeholder and set its partiality to \emph{concern partial}. Any UCMs under the \emph{Authentication Means} feature can extend the root UCM via responsibility mapping. One advantage of using CORE approach in modeling UCMs is that by selecting the desired features when reusing this concern, only the UCMs of those selected features will be composed into the root map and a single UCM that consists of only the necessary paths will be generated. The woven UCM can be reused in another concern such as Online Payment.

\subsection{Online Payment}

\begin{figure}[h]
	\centering
	\includegraphics[scale=1.5]{fig_4_9.png}
	\caption{Feature model for Online Payment}
	\label{fig:4.9}
\end{figure}

\begin{figure}
	\centering
	\includegraphics[scale=1]{fig_4_10.png}
	\caption{Scenario models for Online Payment}
	\label{fig:4.10}
\end{figure}

The Online Payment concern offers a means to build a payment model for an e-commerce platform. Use cases for Online Payment are adapted from the W3C Web Payments Interest Group \cite{w3c2015web}, focusing on the payment schemes in use today. Figure~\ref{fig:4.9} shows all the available features that are supported in the concern. Online Payment provides numerous payment methods for the customers to pay by credit card (e.g., Visa, MasterCard, China UnionPay), tokenized payment (e.g., ApplePay, Venmo, CyberSource), third-party payment (e.g., PayPal, Alipay, Google Pay), cryptocurrency (e.g., Bitcoin, Ripple, Ethereum), direct debit, or credit transfer. Optionally, the system supports a recurring payment option to handle subscription plans, and can also process refunds to the payer's payment instrument or store credit.

Figure~\ref{fig:4.10} illustrates a typical workflow for Online Payment. In the root map, we have a single entry and exit point---from checkout to transaction complete---and a loop that redirects the user back to the payment selection if payment authorization fails. The payment method selection is modeled as a dynamic stub to receive multiple plug-ins from the subfeatures of \emph{PaymentMethod}. We limit the discussion of \emph{PaymentMethod} to \emph{ThirdParty} since the scenario model for paying through third-party is sufficient to describe the essential features, as most payment methods share a similar scenario.

\begin{figure}
	\centering
	\subfloat[Feature selection of Authentication concern]{\label{fig:4.11a}\includegraphics[clip,width=0.7\columnwidth]{fig_4_11a.png}} \\
	\subfloat[Woven Authentication UCM based on selected features]{\label{fig:4.11b}\includegraphics[clip,width=0.7\columnwidth]{fig_4_11b.png}}
	\caption{Reused Authentication in ThirdParty model}
	\label{fig:4.11}
\end{figure}

There are two things worth mentioning in the \emph{ThirdParty} model. First, \emph{ThirdParty} extends \emph{OnlinePayment} through the \emph{Select payment method} dynamic stub, hence mapping is done via connecting points. Second, \emph{ThirdParty} reuses the Authentication concern, which is depicted as a static stub, and the selected features including the root feature are \emph{Authentication}, \emph{Password} and \emph{Auto Logoff}, with \emph{Access Blocking} and \emph{Password Expiry} delayed for future decision (Figure~\ref{fig:4.11a}). The one incoming connection and three outgoing connections of the \emph{Authentication} stub are associated with the single start point (\emph{Authenticate}) and three end points (\emph{Authenticated}, \emph{Fail}, and \emph{Auto logged off}) of the reused Authentication UCM (Figure~\ref{fig:4.11b}).

Optional features of \emph{OnlinePayment} are \emph{RecurringPayment} and \emph{Refund}. Both of the features extend \emph{OnlinePayment}. For \emph{RecurringPayment}, the {\cls Anything} node represents the sequence of nodes on the path of \emph{OnlinePayment}---from \emph{Request payment authorization} to \emph{Close order}---and a loop to enable recurring payment is injected in between the two responsibilities. The \emph{Refund} model we defined here is restricted to the refund policy that allows customers to request for refund after they made the payment, but prior to receiving the goods. Refund after the delivery of product(s) requires a separate UCM and is outside the scope of this case study.

The purpose of these case studies is to demonstrate the application of model reuses, such as the reuse of the Authentication concern in the \emph{ThirdParty} UCM model, as well as model extensions via responsibility mappings and connecting point mappings. Successful application of extensions and reuses allows for the development of scalable and reusable scenario models through TouchCORE. Concerns can be as fine-grained as Authentication, or intermediate concerns that reuse Authentication such as Online Payment, up to a proper application (e.g., electronic commerce websites) that reuses Online Payment.

\section{Workflow Patterns} \label{sec:4.3}

This last section demonstrates the use of CoUCMs to implement some of the workflow patterns described by van der Aalst et al.~\cite{van2003workflow}. We chose to cover two of the state-based patterns---\emph{Deferred Choice} and \emph{Milestone}---as they present the appropriate level of complexity, given that some of the workflow patterns are primitive and already supported by the standard UCM notations, as well as the constraints imposed by our partial implementation of the UCM notations in TouchCORE.

\subsection{Deferred Choice}

The deferred choice pattern allows the moment of choice to be suspended as late as necessary---process can only continue based on external factors. In essence, all branches represent possible future courses of execution. Only once the decision has been made to proceed with a particular branch, execution for the other branches come to a halt. 

\begin{figure}[h]
	\centering
	\includegraphics[scale=1.25]{fig_4_12.png}
	\caption{Deferred choice pattern}
	\label{fig:4.12}
\end{figure}

Typical implementation of deferred choice is using an AND-fork to enable all parallel branches. After one of the branches has started processing, all other branches are canceled. Since the UCM notation does not have the ability to signal for cancellation of other branches, an alternative strategy is the use of XOR-split. Figure~\ref{fig:4.11} illustrates the OR-fork implementation for the deferred choice pattern; the \emph{Trigger} is responsible for activating the proper branch, by setting \emph{option}\textsubscript{1} to \emph{true} and \emph{option}\textsubscript{2} to \emph{false} or vice versa. The pattern is realized as a feature in a concern and can be reused in other UCMs. One example of reuse is in the milestone pattern.

\subsection{Milestone}

The milestone pattern supports the conditional execution of a task only if a parallel process is in a given state, i.e. an activity can only be enabled if a certain milestone has been reached and has not expired yet. Different strategies exist for the implementation of the milestone pattern, and one form uses a deferred choice in the workflow. Deferred choice offers two subsequent activities and is modeled with an OR-fork within the reused Deferred Choice concern. The path to one activity is enabled only after reaching a milestone, after which the path merges prior to the deferred choice construct and the same activity can be executed repeatedly, given that the current state is still in the milestone. On the other hand, if the current state leaves the milestone, then the path to the first activity is disabled by the OR-fork, leaving only the path to the second activity.

\begin{figure}
	\centering
	\includegraphics[scale=1.25]{fig_4_13.png}
	\caption{Milestone pattern (enrolment example)}
	\label{fig:4.13}
\end{figure}

Whereas the deferred choice pattern is modeled as a reusable concern, the milestone pattern is implemented slightly differently. We took an example of student enrolment, applying the milestone pattern (deferred choice implementation), as shown in Figure~\ref{fig:4.12}. New enrolments are being accepted when the enrolment period opens (at the point of reaching a milestone) until the enrolment period closes (at the point of deadline) for a given intake. Ideally, the route to \emph{Enrol student} (\emph{option}\textsubscript{1}) can only be activated when the token on the other parallel path reaches \emph{Open enrolment} but before reaching \emph{Close off}. All other instances would result in inaccessible path \emph{option}\textsubscript{1}, leading to the only exit path available that is \emph{End of enrolment} (\emph{option}\textsubscript{2}).

\todo[inline]{I don't understand in your example how you specify that the "trigger" activity within deferred choice is going to check whether  the enrolment is open or not, and set the correct conditions (option 1 or option 2) for the paths. You don't seem to map "trigger" in your reuse.}